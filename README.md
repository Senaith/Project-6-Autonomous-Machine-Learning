# Project-6-Autonomous-Machine-Learning
## Autonomous machine learning based detection and identification of root cause for incidents in microservices running on EKS

In this project, I will demonstrate an alternative approach that uses the [Zebrium](https://www.zebrium.com/) machine learning (ML) platform to automatically find root cause in logs generated by an application deployed in [Amazon EKS](https://aws.amazon.com/eks/).

## What is Machine Learning?

![ml2](https://user-images.githubusercontent.com/91766546/160332972-e3a7ac47-15aa-46b4-8841-08f5081b8eef.jpg)

Machine learning is a subfield of artificial intelligence, which is broadly defined as the capability of a machine to imitate intelligent human behavior. Artificial intelligence systems are used to perform complex tasks in a way that is similar to how humans solve problems. Machine learning uses algorithms to identify patterns within data, and those patterns are then used to create a data model that can make predictions. With increased data and experience, the results of machine learning are more accurate—much like how humans improve with more practice.

The adaptability of machine learning makes it a great choice in scenarios where the data is always changing, the nature of the request or task are always shifting, or coding a solution would be effectively impossible.

## How does machine learning work?

![ml3](https://user-images.githubusercontent.com/91766546/160333590-2e04c8b0-5453-4829-8b2c-e725968b9652.png)

Machine learning is comprised of different types of machine learning models, using various algorithmic techniques. Depending upon the nature of the data and the desired outcome, one of four learning models can be used: supervised, unsupervised, semi-supervised, or reinforcement. Within each of those models, one or more algorithmic techniques may be applied – relative to the data sets in use and the intended results. Machine learning algorithms are basically designed to classify things, find patterns, predict outcomes, and make informed decisions. Algorithms can be used one at a time or combined to achieve the best possible accuracy when complex and more unpredictable data is involved. 

This project will cover:

- Installing the [Sock Shop](https://microservices-demo.github.io/) microservices demo app in an EKS cluster

<img width="560" alt="sockshop-frontend" src="https://user-images.githubusercontent.com/91766546/160333989-45218f14-8984-4ad9-9d3e-43da5deeede1.png">

- Installing Zebrium log collector
- Breaking the demo app (using a chaos engineering tool) and verifying that the Zebrium platform automatically finds the root cause.

### Prerequisites

1. An active AWS account.
2. AWS CLI with the IAM user having admin permission or having all the permissions to execute the setup.

![ml6](https://user-images.githubusercontent.com/91766546/160336617-3abf0571-7de8-4e9e-ab14-d800d535a628.png)

4. A free [Zebrium](http://www.zebrium.com/sign-up) trial account.

![ml8](https://user-images.githubusercontent.com/91766546/160342645-4c6c2654-d22a-40bf-a09c-80ecf9e18331.png)

### Part 1: Step 1
Create and configure an EKS cluster

The first step is launching a cluster which can be done using eksctl or through the Amazon console. For this cluster, we will use the console but since you still need eksctl that also needs to be installed.

To install eksctl:

![ml9](https://user-images.githubusercontent.com/91766546/160345463-d3a43153-0535-41d2-aee7-d67b2f7a1df0.png)

![ml91](https://user-images.githubusercontent.com/91766546/160345546-f0312070-c182-46d3-b502-8fa84748c678.png)

Confirm your installation:

![ml92](https://user-images.githubusercontent.com/91766546/160345597-b0f76285-299d-4230-a12f-a8cfccc2af1a.png)

### Step 2
Creating an EKS role

![ml93](https://user-images.githubusercontent.com/91766546/160347799-e7b2b13e-a4aa-410c-81e0-4c9f62e517aa.png)

![ml94](https://user-images.githubusercontent.com/91766546/160347865-780789f4-80a3-4227-8e3d-a3178d3f9494.png)

![ml95](https://user-images.githubusercontent.com/91766546/160347904-f85e3c68-c466-452e-8b58-a2a61739c39b.png)

![ml96](https://user-images.githubusercontent.com/91766546/160347969-011ea28b-bae0-47f5-89b7-6d7406b053e8.png)

![ml97](https://user-images.githubusercontent.com/91766546/160348012-dfa9c521-4784-4543-b8ef-7da0f69b41bc.png)

![ml98](https://user-images.githubusercontent.com/91766546/160348064-be1422c9-9b40-4f0c-ae7f-27d26966663c.png)

![ml99](https://user-images.githubusercontent.com/91766546/160348097-e9a18d96-e4ca-43b0-b76c-1b9e51f96e4f.png)

![ml81](https://user-images.githubusercontent.com/91766546/160348201-79110d8a-e08e-4754-a262-bc79ab0d23b1.png)

### Step 3
Creating EKS Node Group role

You need to create an IAM role for Worker nodes. Navigate to the IAM console, select Role on the left navigation tab and select Create role.

![ml82](https://user-images.githubusercontent.com/91766546/160433151-47d06d95-59a9-4e72-a32c-a5186b27607b.png)
On the Select trusted entity page, select EC2 as the use case and then select Next.

![ml83](https://user-images.githubusercontent.com/91766546/160433219-1d94ff4b-b369-4a8c-b6ec-d1f3a67828bc.png)

On the Add permissions page, search and select the 3 policies below for provisioning worker nodes from Amazon EC2. AmazonEKSWorkerNodePolicy AmazonEKS_CNI_Policy AmazonEC2ContainerRegistryReadOnly

![ml84](https://user-images.githubusercontent.com/91766546/160433376-6360db88-d9de-4278-adb5-d1e5561a39bd.png)

![ml85](https://user-images.githubusercontent.com/91766546/160433442-cbf25b27-ea5c-43d7-8965-4ef1050adc62.png)

On the Name, review and create page, give your role a name and you may add a description (optional). Review and make sure all 3 policies are on the Add permission section, scroll to the bottom of the page and select Create role.

![ml86](https://user-images.githubusercontent.com/91766546/160433545-9cf3e928-59c0-4080-8d83-7c3369f83acb.png)

![ml87](https://user-images.githubusercontent.com/91766546/160433642-aff2ab17-d452-4ea1-86b5-4c17d7e76fee.png)

![ml88](https://user-images.githubusercontent.com/91766546/160433686-47e781cb-307e-46b7-be9b-509105983b77.png)

### Step 4
Creating a Cluster

![ml89](https://user-images.githubusercontent.com/91766546/160435168-4dbe0657-5807-43a9-9cd1-3271ae778980.png)

Select Add cluster and then select create

![ml71](https://user-images.githubusercontent.com/91766546/160442481-802bcb33-e1d4-4db6-ae45-f7c3d7a19391.png)

![ml72](https://user-images.githubusercontent.com/91766546/160442528-6e1b4480-4e22-4817-bbe7-fc7943851ede.png)

![ml73](https://user-images.githubusercontent.com/91766546/160442557-a33284bb-3e59-4913-84d9-32c39a29ef85.png)

![ml74](https://user-images.githubusercontent.com/91766546/160442587-5d9c52e2-77e4-4054-ba60-7d982516b9eb.png)

### Step 5
Adding NodeGroups

Select the newly created cluster.

Select the Configuration tab, select Compute under Cluster Configuration.

![ml75](https://user-images.githubusercontent.com/91766546/160442743-aef9b195-4276-46b4-ba67-4b5be4a5d6e0.png)

![ml76](https://user-images.githubusercontent.com/91766546/160442771-b539b2bb-42be-4737-808e-8485eee78559.png)

![ml77](https://user-images.githubusercontent.com/91766546/160442796-383599a6-6824-4b6a-9678-2b944aba6e88.png)

![ml78](https://user-images.githubusercontent.com/91766546/160442826-16edc386-7aaa-4d71-aa23-5c9a09259f63.png)

![ml79](https://user-images.githubusercontent.com/91766546/160442865-6a4ae028-1676-4fd5-bac7-765d0686a4a3.png)

![ml791](https://user-images.githubusercontent.com/91766546/160444183-37e4a9a0-a67a-48bf-a62b-a368eb81f6c6.png)

Connect EKS to the local terminal using AWS CLI.

![ml61](https://user-images.githubusercontent.com/91766546/160501031-b54f39c3-dd87-422b-923f-48b4c277916a.png)
![ml66](https://user-images.githubusercontent.com/91766546/160501570-03b3c04f-00a5-4e45-a6cc-b5394ff17a4a.png)
![ml67](https://user-images.githubusercontent.com/91766546/160501589-a161d4c2-0ff9-48ec-b40b-006b54c0d07b.png)

### Part 2. Create a Zebrium account and install the log collector

You’ll need a free Zebrium trial account (sign up [here](https://cloud.zebrium.com/auth/sign-up)). Create a new account, set your password and then advance to the Send Logs page.

**Important:** Do not install the log collector yet as we’re going to modify the install command!

![ml7](https://user-images.githubusercontent.com/91766546/160470411-5e8a6ef6-9868-43ee-a97a-69c3465bbc61.png)

![ml62](https://user-images.githubusercontent.com/91766546/160471059-3e90d47e-799c-41a6-b411-bacaef2c4f07.png)

Copy the Helm command from the Zebrium Send Logs page and delete the part of the code indicated in red.

![ml68](https://user-images.githubusercontent.com/91766546/160502123-f2059dde-2f49-432a-be43-65d1ce754b77.png)

After I run the Helm command in Terminal, the Zebrium UI should detect that logs have been received. The Zebrium pop-up will look something like this:

![ml63](https://user-images.githubusercontent.com/91766546/160471858-0e8068d7-3861-451f-a1a7-914f517536a2.png)

![ml64](https://user-images.githubusercontent.com/91766546/160480220-6acfebff-4a0a-4cda-9962-3c4353c904a3.png)

![ml65](https://user-images.githubusercontent.com/91766546/160480281-8aad27f1-3d54-40e1-ae3b-fdde76a9c27f.png)

### Part 3. Install and fire up the Sock Shop demo app

[Sock Shop](https://microservices-demo.github.io/) is a really good demo microservices application as it simulates the key components of the user-facing part of an e-commerce website. It is built using Spring Boot, Go kit, and Node.js and is packaged in Docker containers. Visit [this GitHub page](https://github.com/microservices-demo/microservices-demo/blob/master/internal-docs/design.md) to learn more about the application design.

![SockShop2](https://user-images.githubusercontent.com/91766546/160502929-49a53483-690d-4659-97d8-1bcb012f4c48.jpg)

A little bit later, we’re going to install and use the Litmus Chaos Engine to “break” the Sock Shop application. So, we are going to install Sock Shop using a YAML config file that contains annotations for the Litmus Chaos Engine.

![ml69](https://user-images.githubusercontent.com/91766546/160503077-8d0b2ee0-7a5b-4dc1-978b-6c16cb9afefd.png)

Wait until all the pods are in a running state (this can take a few minutes):

![ml51](https://user-images.githubusercontent.com/91766546/160503184-c7e4c67e-a5f1-4858-8266-10e7b24e9a2e.png)

When all the services are running, you can bring up the app in your browser. You will need to set up port forwarding and get the front-end IP address and port by running the command below. You should do this in a separate shell window.

![ml52](https://user-images.githubusercontent.com/91766546/160503320-ea8d5fe9-7201-4597-879b-847d581856ce.png)

![ml53](https://user-images.githubusercontent.com/91766546/160503802-302e1400-8785-4e46-9b18-151e3e346f71.png)

Now use the pod name from the command you just ran in place of XXX’s.

Now open the ip_address:port from above (in this case: 127.0.0.1:8079) in a new browser tab. You should now be able to interact with the Sock Shop app in your browser and verify that it’s working correctly.
![ml54](https://user-images.githubusercontent.com/91766546/160503985-431001bb-eb7f-421c-b128-fa273b97500b.png)
You can also go to CloudWatch in the AWS Console and visit the Resources page under Container Insights to verify that everything looks healthy. Details on how to do this can be found at the [Amazon CloudWatch User Guide](https://docs.aws.amazon.com/AmazonCloudWatch/latest/monitoring/deploy-container-insights-EKS.html).

### Part 4. Install the Litmus Chaos Engine

We’re going to use the open-source Litmus chaos tool to run a chaos experiment that “breaks” the Sock Shop app. Install the required Litmus components using the following commands:

Install Litmus and create an appropriate RBAC role for the pod-network-corruption test by running the next command.
![ml58](https://user-images.githubusercontent.com/91766546/160505171-394d8f6f-2392-4c67-a407-425574963a3a.png)
 
 Followed by:

![ml55](https://user-images.githubusercontent.com/91766546/160505085-4c729caa-5521-4a1f-84a8-a0cfd5db3d0b.png)

![ml56](https://user-images.githubusercontent.com/91766546/160505297-f4e6fbb4-6540-4306-b6a5-013cb97403ff.png)

Setup service account with the appropriate RBAC to run the network corruption experiment
![ml57](https://user-images.githubusercontent.com/91766546/160505351-1903763a-d00b-4f8c-8126-1a87aa859923.png)

Make a note of the time
![ml59](https://user-images.githubusercontent.com/91766546/160505432-92d74e6b-2922-47d2-a5f7-937374f1f5ae.png)

### Part 5. Do something else for two hours!

This is a new EKS cluster and a new app and Zebrium account, so it’s important to give the machine learning a bit of time to learn the normal log patterns. We recommend waiting at least **two hours** before proceeding (you can wait longer if you like).

You can use this time to explore the Zebrium UI.

On the REPORTING page, you should see at least one sample root cause report.

![ml41](https://user-images.githubusercontent.com/91766546/160520275-8150682f-1e66-4202-abce-324ebba07479.png)

Select it and explore how to interact with Root Cause Reports! Make sure you try “peeking” and zooming into Related Events.

You might also see other real root cause reports. If you do, they are likely due to anomalous patterns in the logs that occur during the bring-up of the new environment (Zebrium sees them as being anomalous because it doesn’t have much history to go on at this stage). Again, feel free to poke around.

### Part 6: Run a network corrupt choas experiment to break the Sock Shop app
Now that ML has had a chance to get a baseline of the logs, you will break the environment by running a Litmus network corruption chaos experiment.

To start the network corruption, run:

![ml42](https://user-images.githubusercontent.com/91766546/160520552-a8a964a2-f072-45a4-b5f3-a830b8324f0e.png)

Make note  of the date

![ml43](https://user-images.githubusercontent.com/91766546/160520996-f2de9aae-fa9b-4229-8015-a98f13361815.png)

It will take a minute or so for the experiment to start. You can tell that it’s running when the pod-network-corruption-helper goes into a Running state.  

![ml44](https://user-images.githubusercontent.com/91766546/160521325-3f01c9fd-22ab-4c40-8514-5a11ca6d3754.png)

Monitor its progress with kubectl (the -w option waits for output, so hit ^C once you see that everything is running):
![ml31](https://user-images.githubusercontent.com/91766546/160526397-7d8a2a8b-39db-481b-9fc9-d9dacf609779.png)

It takes awhile for the experiment to start, so you have to wait until the pod-network-corruption-helper goes into a Running state. Click shift C (^C) once everything is running.

Refresh your Sock Shop UI, you might notice some operations failing or not operating the way it should.

![ml45](https://user-images.githubusercontent.com/91766546/160523625-3363c280-bc5a-49df-921c-91bed9e62f7a.png)
In my case, there was no visible change, except the time it took for an item to be added into the cart and the fact that the blue "Items in the cart" button wasn't accessible. Yours will be different but we will use Zebrium to understand the issue that has occurred.

![ml33](https://user-images.githubusercontent.com/91766546/160526910-8d8a252d-7742-4623-bff8-10fe5d1d83b2.png)

### Part 7. The results and how to interpret them

Please give the machine learning a few minutes to detect the problem (typically 2 to 10 minutes) and then refresh your browser window until you see one or more new root cause reports **(UI refresh is NOT automatic)**.

I tried the above procedure several times and saw really awesome results after each run. However, the actual root cause reports were different across runs. This is because of many factors, including the learning period, what events occurred while learning, the timing and order of the log lines while the experiment was running, other things happening on the system, and so on.

![ml46](https://user-images.githubusercontent.com/91766546/160524192-d55011dc-29ba-48e9-b810-c422a38401ed.png)

The reporting page contains a summary list of all the root cause reports found by the machine learning. There are three useful parts of the summary:

Plain language NLP summary  This is an experimental feature where we use the GPT-3 language model to construct a summary of the report. The summary provides some useful context about the problem.

Log type(s) and host(s) The log type and host (front end, events, orders, and messages) that contain the events for the incident.

“Hallmark” events The ML picks out one or two events that it believes will define the problem.

After running the Chaos experiment, Zebrium generated a series of reports. Here is a summary of the root cause errors that were generated in my Zebrium account. Clicking on the summary lets you drill down into the details of the root cause report. The core events represent the cluster of correlated anomalies that the ML picks out. The most important ones are the events that are either “rare” or”bad”.

![ml47](https://user-images.githubusercontent.com/91766546/160527197-398cab0c-1d07-4b56-82de-e45e1c2fe15e.png)

![ml48](https://user-images.githubusercontent.com/91766546/160527230-96c4cff2-72ce-41bc-9459-ae08baff3c8b.png)

The process of troubleshooting and tracking down the root cause of an incident in a distributed application is becoming more and more difficult and time-consuming.

## Conclusion

In this project, we showed how to induce a failure in the Sock Shop microservices application by running a Litmus network corruption chaos experiment. The Zebrium machine learning technology was able to detect this and build a root cause report that detailed the root cause.

This experiment shows how you can use machine learning to automatically find a correlated cluster of anomalies that represents a set of log lines that explains the root cause. The technology is designed to work with any kind of application and does not require manual training or large training data sets.

Congratulations!!! you have successfully completed this project.

                      ![m](https://user-images.githubusercontent.com/91766546/160527652-931eaebf-c905-4b70-8e9f-60bff45ebb37.jpeg)
